---
layout: post
title:  "[计算机技术] 代码优化-综述"
date:   2020-04-07 01:43:52 +0800
categories: [计算机技术, 优化]
---
> "Premature optimization is the root of all evil."

## 概述

针对C++代码的优化，主要可以分为：*线性代码优化*；*缓存读写优化*和*并行优化*。本章只概述每一个的根据和大概方法，接下来博客会针对每种优化进行详细分析。

### 线性代码优化

在一个线性代码块中，程序的运行顺序以及依赖关系可以用有向图表示，例如

```c++
int a = x;
int b = a * 2;
```

上两行程序，第二行乘法必须在第一行读取操作完成之后进行。因此可以构建一个有向图，在这个有向图中，读取，储存，整数加减乘除，浮点数加减乘除分别有不同的时间延迟和吞吐量（即cpu支持并行执行的指令个数）。优化的目的是首先分析出原有代码的**关键路径**，并对关键路径进行简化。

这些优化有一个重要的依据，即**ILP**(Instruction Level Parallelism)，即代码指令并不是严格按照所写的顺序执行，相反，他们会被cpu硬件送入一个池子里，CPU每次选择没有依赖的指令执行，类似于拓扑排序。这一设计的结果是cpu仅按照有向图拓扑排序的顺序执行指令，而优化的目的也变成保证指令间相互依赖关系最小。

另一个需要注意的点是，编译器功能很强大，会一定程度上修改汇编指令层面的执行顺序，因此需要注意代码代码层面的优化不应该是那些编译器已经帮我们完成了的操作。

[传送门]({% link 404.html %})

### 缓存读写优化

缓存读写优化的依据是，**L1缓存**速度快，容量小，**L2,L3缓存**次之，内存容量大，速度慢。因此我们希望尽可能多用**L1缓存**，少用内存。而如果所有的数据读写位置是随机的，那么缓存读写优化就毫无意义，但实际上，大多数读写指令满足两个性质：**temporal locality**和**spatial locality**，前者指之前访问的数据过会儿还大概率会访问，后者指访问当前数据揭下来大概率会访问其相邻位置的数据，如数组。

因此，缓存读写优化的目的是尽可能把每个数据以及其相邻数据一次性处理完，从此再也不访问，完美利用上述亮点性质。这一般在多维数组中较常用，如矩阵乘法，图像处理等。

对于gpu而言，**thread private memory**和**shared memory**对cpu中的**L1,L2缓存**，而**global memory**对应内存，思路类似。

另外，内存的数据需要从硬盘读取，而这又涉及到分页的问题，不过这些相关问题一般不需要程序员自己优化，因此此处忽略。

[传送门]({% link 404.html %})

### 并行优化

并行优化这里只介绍_共享内存_和_消息传递_。

_共享内存_ 即把一个大的共享内存划分成许多独立的小份并分别分配给每个线程运行。首先在任务负担均等的情况下，涉及到的一个主要问题是如何划分任务，使得对于**缓存**读写最友好，*halide*和最近爆火的*taichi*很大程度上都在解决这一个问题。而当任务负载无法预测时，就需要利用**内存池**合理分配任务。

另一个_共享内存_的问题是不同线程同时写入同个地址的时候，可能会发生**race condition**，**dead lock**和**live lock**。这里就涉及到**mutual mutex lock**的设计，**memory model**的原理等。锁很复杂，常见情况是A发表论文说我发现了线程安全的锁，过几天B说A的设计有bug，需要这样修改，再过几天C再发表论文说B的设计有另一个bug，如此一直套娃。

本博客仅讨论作为一般的程序员，在运用已有的并行库时需要注意的事项和可能出错的点，更具体的有关多个**内存池**之间**stealing thread**，锁的设计，原子性的讨论，无锁数据结构的实现等等，可以参考[cpp concurrency in action](https://chenxiaowei.gitbook.io/cpp_concurrency_in_action/)。

_消息传递_这一主题主要出现在网络通信中，例如多个集群之间的通信，由于并不常用，本博客对其理解也较浅薄，仅介绍基础原理供参考，若有一日需要自己亲自解决多机并行等问题，再把详细内容补上。

[传送门]({% link 404.html %})

### 讨论

优化代码路上最大的一个绊脚石是**抽象**这一概念。**抽象**把代码实现和表示分开，层级封装，使得代码的可读性和整体结构非常棒。但优化往往意味着降低可读性，破坏抽象。根据经验，我认为优化一定要为**抽象**让道，即使付出额外的不需要的计算复杂度，也不可以破坏**抽象**性。破坏的后果是代码可扩展性急剧变差，同时维护成本急剧提高，甚至最终无法维护。